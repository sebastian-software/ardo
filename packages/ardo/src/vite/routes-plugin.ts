import type { Plugin } from "vite"
import fs from "fs/promises"
import fsSync from "fs"
import path from "path"

export interface ArdoRoutesPluginOptions {
  /** Directory where routes are located (default: "./app/routes") */
  routesDir?: string
}

interface RouteInfo {
  /** URL path (e.g., "/guide/getting-started") */
  path: string
  /** File path relative to app directory (e.g., "routes/guide/getting-started.mdx") */
  file: string
  /** True if this is an index route */
  isIndex?: boolean
}

/**
 * Vite plugin that generates routes.ts for React Router Framework Mode.
 * Scans app/routes for .mdx and .tsx files and generates the route configuration.
 */
export function ardoRoutesPlugin(options: ArdoRoutesPluginOptions = {}): Plugin {
  let routesDir: string
  let appDir: string
  let routesFilePath: string

  function scanRoutesSync(dir: string, rootDir: string): RouteInfo[] {
    const routes: RouteInfo[] = []

    try {
      const entries = fsSync.readdirSync(dir, { withFileTypes: true })

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name)

        if (entry.isDirectory()) {
          // Recursively scan subdirectories
          const children = scanRoutesSync(fullPath, rootDir)
          routes.push(...children)
        } else if (
          entry.name.endsWith(".mdx") ||
          entry.name.endsWith(".md") ||
          entry.name.endsWith(".tsx")
        ) {
          // Skip special files
          if (entry.name === "root.tsx" || entry.name.startsWith("_")) {
            continue
          }

          const relativePath = path.relative(rootDir, fullPath)
          const ext = entry.name.endsWith(".mdx")
            ? ".mdx"
            : entry.name.endsWith(".md")
              ? ".md"
              : ".tsx"
          const baseName = entry.name.replace(ext, "")

          // Calculate URL path
          let urlPath: string
          if (baseName === "index" || baseName === "home") {
            // Index route - use parent directory path
            const parentDir = path.dirname(relativePath)
            urlPath = parentDir === "." ? "/" : "/" + parentDir.replace(/\\/g, "/")
          } else {
            // Regular route
            urlPath = "/" + relativePath.replace(ext, "").replace(/\\/g, "/")
          }

          // Handle dynamic segments ($param -> :param)
          urlPath = urlPath.replace(/\$(\w+)/g, ":$1")

          routes.push({
            path: urlPath,
            file: "routes/" + relativePath.replace(/\\/g, "/"),
            isIndex: baseName === "index" || baseName === "home",
          })
        }
      }
    } catch {
      // Directory may not exist yet
    }

    return routes
  }

  function generateRoutesFile(routes: RouteInfo[]): string {
    // Sort routes: index routes first, then alphabetically
    const sortedRoutes = [...routes].sort((a, b) => {
      if (a.path === "/" && b.path !== "/") return -1
      if (b.path === "/" && a.path !== "/") return 1
      if (a.isIndex && !b.isIndex) return -1
      if (b.isIndex && !a.isIndex) return 1
      return a.path.localeCompare(b.path)
    })

    const entries = sortedRoutes.map((r) => {
      if (r.path === "/") {
        return `  index("${r.file}"),`
      }
      // Remove leading slash for route path
      const routePath = r.path.substring(1)
      return `  route("${routePath}", "${r.file}"),`
    })

    return `// AUTO-GENERATED by Ardo - Do not edit manually

import { type RouteConfig, route, index } from "@react-router/dev/routes"

export default [
${entries.join("\n")}
] satisfies RouteConfig
`
  }

  function writeRoutesFileSync(): void {
    const routes = scanRoutesSync(routesDir, routesDir)

    // Skip if no routes found (directory might not exist yet)
    if (routes.length === 0) {
      return
    }

    const content = generateRoutesFile(routes)

    // Only write if content changed
    try {
      const existing = fsSync.readFileSync(routesFilePath, "utf-8")
      if (existing === content) {
        return
      }
    } catch {
      // File doesn't exist yet
    }

    // Ensure app directory exists
    fsSync.mkdirSync(appDir, { recursive: true })
    fsSync.writeFileSync(routesFilePath, content, "utf-8")
    console.log(`[ardo] Generated routes.ts with ${routes.length} routes`)
  }

  async function writeRoutesFile(): Promise<void> {
    const routes = scanRoutesSync(routesDir, routesDir)

    // Skip if no routes found (directory might not exist yet)
    if (routes.length === 0) {
      return
    }

    const content = generateRoutesFile(routes)

    // Only write if content changed
    try {
      const existing = await fs.readFile(routesFilePath, "utf-8")
      if (existing === content) {
        return
      }
    } catch {
      // File doesn't exist yet
    }

    // Ensure app directory exists
    await fs.mkdir(appDir, { recursive: true })
    await fs.writeFile(routesFilePath, content, "utf-8")
  }

  return {
    name: "ardo:routes",
    enforce: "pre",

    config(userConfig) {
      const root = userConfig.root || process.cwd()
      appDir = path.join(root, "app")
      routesDir = options.routesDir || path.join(appDir, "routes")
      routesFilePath = path.join(appDir, "routes.ts")

      // Generate routes synchronously during config phase
      // React Router needs routes.ts to exist before it starts
      try {
        writeRoutesFileSync()
      } catch (err) {
        console.warn("[ardo] Could not generate routes.ts in config phase:", err)
      }
    },

    configResolved(config) {
      // Update paths if not set in config
      if (!appDir) {
        appDir = path.join(config.root, "app")
        routesDir = options.routesDir || path.join(appDir, "routes")
        routesFilePath = path.join(appDir, "routes.ts")
      }
    },

    async buildStart() {
      // Re-generate routes in buildStart for async support
      await writeRoutesFile()
    },

    configureServer(server) {
      // Watch for changes in routes directory
      server.watcher.add(routesDir)

      const handleChange = async (changedPath: string) => {
        if (
          changedPath.startsWith(routesDir) &&
          (changedPath.endsWith(".mdx") ||
            changedPath.endsWith(".md") ||
            changedPath.endsWith(".tsx"))
        ) {
          await writeRoutesFile()
        }
      }

      server.watcher.on("add", handleChange)
      server.watcher.on("unlink", handleChange)
    },
  }
}
