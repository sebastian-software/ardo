import type { Plugin } from 'vite'
import type { ResolvedConfig } from '../config/types'
import fs from 'fs/promises'
import path from 'path'

export interface PressRoutesPluginOptions {
  /** Directory where routes should be generated */
  routesDir?: string
  /** Route group name (default: 'press') */
  routeGroup?: string
}

interface RouteInfo {
  /** Path relative to content dir without extension (e.g., 'guide/getting-started') */
  slug: string
  /** Full path to the markdown file */
  mdPath: string
  /** Path relative to content dir with extension (e.g., 'guide/getting-started.md') */
  relativePath: string
}

/**
 * Vite plugin that generates individual route files for each markdown file
 * in the content directory. This replaces the splat route approach with
 * properly typed, individual routes.
 */
export function pressRoutesPlugin(
  getConfig: () => ResolvedConfig,
  options: PressRoutesPluginOptions = {}
): Plugin {
  const { routeGroup = 'press' } = options

  let routesDir: string
  let contentDir: string

  async function scanContentDir(dir: string, rootDir: string): Promise<RouteInfo[]> {
    const routes: RouteInfo[] = []
    const entries = await fs.readdir(dir, { withFileTypes: true })

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name)

      if (entry.isDirectory()) {
        const children = await scanContentDir(fullPath, rootDir)
        routes.push(...children)
      } else if (entry.name.endsWith('.md') && entry.name !== 'index.md') {
        const relativePath = path.relative(rootDir, fullPath)
        const slug = relativePath.replace(/\.md$/, '').replace(/\\/g, '/')

        routes.push({
          slug,
          mdPath: fullPath,
          relativePath: relativePath.replace(/\\/g, '/'),
        })
      } else if (entry.name === 'index.md') {
        const parentDir = path.dirname(fullPath)
        const relativePath = path.relative(rootDir, fullPath)

        // Skip root index.md (handled by manual index.tsx)
        if (parentDir !== rootDir) {
          const slug = path.relative(rootDir, parentDir).replace(/\\/g, '/')

          routes.push({
            slug,
            mdPath: fullPath,
            relativePath: relativePath.replace(/\\/g, '/'),
          })
        }
      }
    }

    return routes
  }

  function generateRouteCode(route: RouteInfo): string {
    const { slug, relativePath } = route

    // Calculate relative path from route file to content file
    // Route file is at: src/routes/(press)/{slug}.tsx
    // Content is at: content/{relativePath}
    // We need to traverse: api/ (if nested) + (press)/ + routes/ + src/ = slug.split('/').length + 2
    const depthToProjectRoot = slug.split('/').length + 2
    const toProjectRoot = '../'.repeat(depthToProjectRoot)
    const contentImportPath = `${toProjectRoot}content/${relativePath}`

    // Generate component name from slug
    const componentName =
      slug
        .split('/')
        .map((part) => part.replace(/[-_]/g, ' ').replace(/\b\w/g, (c) => c.toUpperCase()))
        .join('')
        .replace(/\s/g, '') + 'Page'

    // Generate route path for TanStack Router
    const routePath = `/(${routeGroup})/${slug}`

    return `// This file is auto-generated by ardo. Do not edit manually.
import { createFileRoute } from '@tanstack/react-router'
import { DocPage } from 'ardo/theme'
import { PressProvider } from 'ardo/runtime'
import config from 'virtual:ardo/config'
import sidebar from 'virtual:ardo/sidebar'
import Content, { frontmatter, toc } from '${contentImportPath}'

export const Route = createFileRoute('${routePath}')({
  component: ${componentName},
})

function ${componentName}() {
  const pageData = {
    title: (frontmatter.title as string) || '${slug.split('/').pop()}',
    description: frontmatter.description as string | undefined,
    frontmatter,
    toc,
    filePath: '${relativePath}',
    relativePath: '${relativePath}',
  }

  return (
    <PressProvider config={config} sidebar={sidebar} currentPage={pageData}>
      <DocPage>
        <Content />
      </DocPage>
    </PressProvider>
  )
}
`
  }

  async function ensureDirectoryExists(dir: string): Promise<void> {
    try {
      await fs.mkdir(dir, { recursive: true })
    } catch {
      // Directory may already exist
    }
  }

  async function writeRouteFile(route: RouteInfo): Promise<boolean> {
    const routeFilePath = path.join(routesDir, `(${routeGroup})`, `${route.slug}.tsx`)
    const routeFileDir = path.dirname(routeFilePath)

    await ensureDirectoryExists(routeFileDir)

    const code = generateRouteCode(route)

    // Only write if content changed to avoid triggering unnecessary rebuilds
    try {
      const existingContent = await fs.readFile(routeFilePath, 'utf-8')
      if (existingContent === code) {
        return false // No change
      }
    } catch {
      // File doesn't exist, will be created
    }

    await fs.writeFile(routeFilePath, code, 'utf-8')
    return true // File was written
  }

  async function cleanGeneratedRoutes(): Promise<void> {
    const pressRoutesDir = path.join(routesDir, `(${routeGroup})`)

    try {
      await fs.rm(pressRoutesDir, { recursive: true, force: true })
    } catch {
      // Directory may not exist
    }
  }

  async function generateAllRoutes(): Promise<void> {
    // Scan for all markdown files
    const routes = await scanContentDir(contentDir, contentDir)

    // In dev mode, clean old routes on first run to remove stale files
    // In build mode, don't clean (routes are already fresh from previous build or dev run)
    if (isDevMode && !hasCleanedRoutes) {
      await cleanGeneratedRoutes()
      hasCleanedRoutes = true
    }

    // Ensure all directories exist first
    const dirs = new Set<string>()
    for (const route of routes) {
      const routeFilePath = path.join(routesDir, `(${routeGroup})`, `${route.slug}.tsx`)
      dirs.add(path.dirname(routeFilePath))
    }
    await Promise.all([...dirs].map((dir) => ensureDirectoryExists(dir)))

    // Generate all route files in parallel (only writes if content changed)
    const results = await Promise.all(routes.map((route) => writeRouteFile(route)))
    const writtenCount = results.filter(Boolean).length

    if (writtenCount > 0) {
      console.log(`[ardo] Generated ${writtenCount} route files`)
    }
  }

  let isDevMode = false
  let hasCleanedRoutes = false
  let hasGeneratedRoutes = false

  return {
    name: 'ardo:routes',
    enforce: 'pre',

    async config(userConfig, env) {
      // Generate routes early, before TanStack Router scans the files
      // We need to resolve paths manually here since viteConfig isn't available yet
      const root = userConfig.root || process.cwd()
      routesDir = options.routesDir || path.join(root, 'src', 'routes')
      isDevMode = env.command === 'serve'

      // Try to load the press config to get contentDir
      const configPath = path.resolve(root, 'press.config.ts')
      try {
        const configModule = await import(configPath)
        const pressConfig = configModule.default
        contentDir = path.resolve(root, pressConfig.srcDir || 'content')

        // Generate routes now, before other plugins run
        await generateAllRoutes()
        hasGeneratedRoutes = true
      } catch {
        // Config not found or error loading, will try again in buildStart
        console.warn(
          '[ardo] Could not load config in early phase, routes will be generated in buildStart'
        )
      }
    },

    configResolved(viteConfig) {
      // Update paths if they weren't set in config hook
      if (!routesDir) {
        routesDir = options.routesDir || path.join(viteConfig.root, 'src', 'routes')
        isDevMode = viteConfig.command === 'serve'
      }
    },

    async buildStart() {
      // Only generate routes here if we couldn't do it in the config hook
      if (!hasGeneratedRoutes) {
        const config = getConfig()
        contentDir = config.contentDir
        await generateAllRoutes()
      }
    },

    async handleHotUpdate({ file, server }) {
      // Only handle markdown files in content directory
      if (!file.endsWith('.md') || !file.startsWith(contentDir)) {
        return
      }

      const relativePath = path.relative(contentDir, file).replace(/\\/g, '/')
      const isIndex = relativePath.endsWith('index.md')

      // Skip root index.md
      if (relativePath === 'index.md') {
        return
      }

      let slug: string
      if (isIndex) {
        slug = path.dirname(relativePath)
      } else {
        slug = relativePath.replace(/\.md$/, '')
      }

      const route: RouteInfo = {
        slug,
        mdPath: file,
        relativePath,
      }

      let needsReload = false

      // Check if file was deleted
      try {
        await fs.access(file)
        // File exists, regenerate route (only if content changed)
        const wasWritten = await writeRouteFile(route)
        if (wasWritten) {
          console.log(`[ardo] Regenerated route: ${slug}`)
          needsReload = true
        }
      } catch {
        // File was deleted, remove route
        const routeFilePath = path.join(routesDir, `(${routeGroup})`, `${slug}.tsx`)
        try {
          await fs.unlink(routeFilePath)
          console.log(`[ardo] Removed route: ${slug}`)
          needsReload = true
        } catch {
          // Route file may not exist
        }
      }

      // Only trigger reload if route file actually changed
      if (needsReload) {
        server.ws.send({
          type: 'full-reload',
          path: '*',
        })
      }
    },
  }
}
