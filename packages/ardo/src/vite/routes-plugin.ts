import type { Plugin } from "vite"
import type { ResolvedConfig } from "../config/types"
import fs from "fs/promises"
import fsSync from "fs"
import path from "path"

export interface PressRoutesPluginOptions {
  /** Directory where routes should be generated */
  routesDir?: string
  /** Source directory for content (default: 'content') */
  srcDir?: string
  /**
   * Layout mode for generated routes.
   * - 'docPage': Routes use DocPage which includes Layout (backward compatible)
   * - 'layoutRoute': Routes use DocContent without Layout (for use with _layout.tsx)
   * Default: 'layoutRoute'
   */
  layoutMode?: "docPage" | "layoutRoute"
}

interface RouteInfo {
  /** Path relative to content dir without extension (e.g., 'guide/getting-started') */
  slug: string
  /** Full path to the markdown file */
  mdPath: string
  /** Path relative to content dir with extension (e.g., 'guide/getting-started.md') */
  relativePath: string
  /** True if this route comes from an index.md file */
  isIndex?: boolean
}

/**
 * Vite plugin that generates individual route files for each markdown file
 * in the content directory. Routes include SEO head() configuration
 * using frontmatter data.
 */
export function pressRoutesPlugin(
  getConfig: () => ResolvedConfig,
  options: PressRoutesPluginOptions = {}
): Plugin {
  const { layoutMode = "layoutRoute" } = options

  let routesDir: string
  let contentDir: string
  let isDevMode = false
  let hasCleanedRoutes = false

  function scanContentDirSync(dir: string, rootDir: string): RouteInfo[] {
    const routes: RouteInfo[] = []

    try {
      const entries = fsSync.readdirSync(dir, { withFileTypes: true })

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name)

        if (entry.isDirectory()) {
          const children = scanContentDirSync(fullPath, rootDir)
          routes.push(...children)
        } else if (entry.name.endsWith(".md") && entry.name !== "index.md") {
          const relativePath = path.relative(rootDir, fullPath)
          const slug = relativePath.replace(/\.md$/, "").replace(/\\/g, "/")

          routes.push({
            slug,
            mdPath: fullPath,
            relativePath: relativePath.replace(/\\/g, "/"),
          })
        } else if (entry.name === "index.md") {
          const parentDir = path.dirname(fullPath)
          const relativePath = path.relative(rootDir, fullPath)

          // Skip root index.md (handled by manual index.tsx)
          if (parentDir !== rootDir) {
            const slug = path.relative(rootDir, parentDir).replace(/\\/g, "/")

            routes.push({
              slug,
              mdPath: fullPath,
              relativePath: relativePath.replace(/\\/g, "/"),
              isIndex: true, // Mark as index route
            })
          }
        }
      }
    } catch {
      // Content dir may not exist
    }

    return routes
  }

  function generateRouteCode(route: RouteInfo): string {
    const { slug, relativePath, isIndex } = route

    // Calculate relative path from route file to content file
    // Route at routes/${slug}.tsx needs to reach content/${relativePath}
    // Index routes are at routes/${slug}/index.tsx, so they need one more level up
    const baseDepth = slug.split("/").length + 1
    const depthToProjectRoot = isIndex ? baseDepth + 1 : baseDepth
    const toProjectRoot = "../".repeat(depthToProjectRoot)
    const contentImportPath = `${toProjectRoot}content/${relativePath}`

    // Generate component name from slug
    const componentName =
      slug
        .split("/")
        .map((part) => part.replace(/[-_]/g, " ").replace(/\b\w/g, (c) => c.toUpperCase()))
        .join("")
        .replace(/\s/g, "") + "Page"

    // Generate route path for TanStack Router (no route group, direct path)
    const routePath = `/${slug}`

    // Generate default title from slug
    const defaultTitle = slug
      .split("/")
      .pop()!
      .replace(/[-_]/g, " ")
      .replace(/\b\w/g, (c) => c.toUpperCase())

    // Choose component based on layout mode
    const contentComponent = layoutMode === "docPage" ? "DocPage" : "DocContent"

    return `// This file is auto-generated by ardo. Do not edit manually.
import { createFileRoute } from '@tanstack/react-router'
import { ${contentComponent} } from 'ardo/theme'
import { PressProvider } from 'ardo/runtime'
import config from 'virtual:ardo/config'
import sidebar from 'virtual:ardo/sidebar'
import Content, { frontmatter, toc } from '${contentImportPath}'

export const Route = createFileRoute('${routePath}')({
  head: () => ({
    meta: [
      { title: (frontmatter.title as string) ? \`\${frontmatter.title} | \${config.title}\` : config.title },
      ...(frontmatter.description ? [{ name: 'description', content: frontmatter.description as string }] : []),
      // OpenGraph
      { property: 'og:title', content: (frontmatter.title as string) || '${defaultTitle}' },
      ...(frontmatter.description ? [{ property: 'og:description', content: frontmatter.description as string }] : []),
      { property: 'og:type', content: 'article' },
      // Twitter
      { name: 'twitter:card', content: 'summary' },
      { name: 'twitter:title', content: (frontmatter.title as string) || '${defaultTitle}' },
      ...(frontmatter.description ? [{ name: 'twitter:description', content: frontmatter.description as string }] : []),
    ],
  }),
  component: ${componentName},
})

function ${componentName}() {
  const pageData = {
    title: (frontmatter.title as string) || '${defaultTitle}',
    description: frontmatter.description as string | undefined,
    frontmatter,
    content: '',
    toc,
    filePath: '${relativePath}',
    relativePath: '${relativePath}',
  }

  return (
    <PressProvider config={config} sidebar={sidebar} currentPage={pageData}>
      <${contentComponent}>
        <Content />
      </${contentComponent}>
    </PressProvider>
  )
}
`
  }

  function writeRouteFileSync(route: RouteInfo): boolean {
    // Index routes go to {slug}/index.tsx to avoid TanStack Router treating them as layout routes
    const routeFilePath = route.isIndex
      ? path.join(routesDir, route.slug, "index.tsx")
      : path.join(routesDir, `${route.slug}.tsx`)
    const code = generateRouteCode(route)

    // Only write if content changed
    try {
      const existingContent = fsSync.readFileSync(routeFilePath, "utf-8")
      if (existingContent === code) {
        return false
      }
    } catch {
      // File doesn't exist, will be created
    }

    fsSync.mkdirSync(path.dirname(routeFilePath), { recursive: true })
    fsSync.writeFileSync(routeFilePath, code, "utf-8")
    return true
  }

  function generateAllRoutesSync(): void {
    const routes = scanContentDirSync(contentDir, contentDir)

    let writtenCount = 0
    for (const route of routes) {
      if (writeRouteFileSync(route)) {
        writtenCount++
      }
    }

    if (writtenCount > 0) {
      console.log(`[ardo] Generated ${writtenCount} content route files`)
    }
  }

  async function ensureDirectoryExists(dir: string): Promise<void> {
    try {
      await fs.mkdir(dir, { recursive: true })
    } catch {
      // Directory may already exist
    }
  }

  async function writeRouteFile(route: RouteInfo): Promise<boolean> {
    // Index routes go to {slug}/index.tsx to avoid TanStack Router treating them as layout routes
    const routeFilePath = route.isIndex
      ? path.join(routesDir, route.slug, "index.tsx")
      : path.join(routesDir, `${route.slug}.tsx`)
    const routeFileDir = path.dirname(routeFilePath)

    await ensureDirectoryExists(routeFileDir)

    const code = generateRouteCode(route)

    // Only write if content changed to avoid triggering unnecessary rebuilds
    try {
      const existingContent = await fs.readFile(routeFilePath, "utf-8")
      if (existingContent === code) {
        return false // No change
      }
    } catch {
      // File doesn't exist, will be created
    }

    await fs.writeFile(routeFilePath, code, "utf-8")
    return true // File was written
  }

  async function cleanGeneratedRoutes(): Promise<void> {
    const pressRoutesDir = routesDir

    try {
      const entries = await fs.readdir(pressRoutesDir, { withFileTypes: true, recursive: true })

      for (const entry of entries) {
        if (entry.isFile() && entry.name.endsWith(".tsx") && entry.name !== "_layout.tsx") {
          const fullPath = path.join(entry.parentPath ?? pressRoutesDir, entry.name)

          // Read the file to check if it's auto-generated
          try {
            const content = await fs.readFile(fullPath, "utf-8")
            if (content.startsWith("// This file is auto-generated by ardo")) {
              await fs.unlink(fullPath)
            }
          } catch {
            // File might have been deleted already
          }
        }
      }
    } catch {
      // Directory doesn't exist yet, nothing to clean
    }
  }

  async function scanContentDir(dir: string, rootDir: string): Promise<RouteInfo[]> {
    const routes: RouteInfo[] = []
    const entries = await fs.readdir(dir, { withFileTypes: true })

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name)

      if (entry.isDirectory()) {
        const children = await scanContentDir(fullPath, rootDir)
        routes.push(...children)
      } else if (entry.name.endsWith(".md") && entry.name !== "index.md") {
        const relativePath = path.relative(rootDir, fullPath)
        const slug = relativePath.replace(/\.md$/, "").replace(/\\/g, "/")

        routes.push({
          slug,
          mdPath: fullPath,
          relativePath: relativePath.replace(/\\/g, "/"),
        })
      } else if (entry.name === "index.md") {
        const parentDir = path.dirname(fullPath)
        const relativePath = path.relative(rootDir, fullPath)

        // Skip root index.md (handled by manual index.tsx)
        if (parentDir !== rootDir) {
          const slug = path.relative(rootDir, parentDir).replace(/\\/g, "/")

          routes.push({
            slug,
            mdPath: fullPath,
            relativePath: relativePath.replace(/\\/g, "/"),
            isIndex: true, // Mark as index route
          })
        }
      }
    }

    return routes
  }

  async function generateAllRoutes(): Promise<void> {
    // Clean old generated routes first (only in dev mode, and only once)
    if (isDevMode && !hasCleanedRoutes) {
      await cleanGeneratedRoutes()
      hasCleanedRoutes = true
    }

    const routes = await scanContentDir(contentDir, contentDir)

    let writtenCount = 0
    for (const route of routes) {
      if (await writeRouteFile(route)) {
        writtenCount++
      }
    }

    if (writtenCount > 0) {
      console.log(`[ardo] Generated ${writtenCount} content route files`)
    }
  }

  return {
    name: "ardo:routes",
    enforce: "pre",

    config(userConfig, env) {
      // Generate routes early, before TanStack Router scans the files
      const root = userConfig.root || process.cwd()
      const srcDir = path.join(root, "src")
      routesDir = options.routesDir || path.join(srcDir, "routes")
      isDevMode = env.command === "serve"

      // Use srcDir from options to resolve contentDir early
      contentDir = path.resolve(root, options.srcDir || "content")

      // Generate content routes SYNCHRONOUSLY
      // TanStack Router scans routes during config phase, so routes must exist by then
      try {
        generateAllRoutesSync()
      } catch (err) {
        console.warn("[ardo] Could not generate routes in config phase:", err)
      }
    },

    configResolved(viteConfig) {
      // Update paths if they weren't set in config hook
      if (!routesDir) {
        routesDir = options.routesDir || path.join(viteConfig.root, "src", "routes")
        isDevMode = viteConfig.command === "serve"
      }
    },

    async buildStart() {
      // Re-generate content routes in buildStart for full async support
      const config = getConfig()
      contentDir = config.contentDir
      await generateAllRoutes()
    },

    configureServer(server) {
      // Watch for changes in content directory
      server.watcher.add(contentDir)

      server.watcher.on("change", async (changedPath) => {
        if (changedPath.startsWith(contentDir) && changedPath.endsWith(".md")) {
          await generateAllRoutes()
        }
      })

      server.watcher.on("add", async (addedPath) => {
        if (addedPath.startsWith(contentDir) && addedPath.endsWith(".md")) {
          await generateAllRoutes()
        }
      })

      server.watcher.on("unlink", async (removedPath) => {
        if (removedPath.startsWith(contentDir) && removedPath.endsWith(".md")) {
          // Re-generate routes (will clean up orphaned route files)
          hasCleanedRoutes = false // Allow cleaning again
          await generateAllRoutes()
        }
      })
    },
  }
}
