import type { Plugin } from 'vite'
import type { ResolvedConfig } from '../config/types'
import fs from 'fs/promises'
import fsSync from 'fs'
import path from 'path'

export interface PressRoutesPluginOptions {
  /** Directory where routes should be generated */
  routesDir?: string
  /** Route group name (default: 'docs') */
  routeGroup?: string
  /** Source directory for content (default: 'content') */
  srcDir?: string
  /**
   * Layout mode for generated routes.
   * - 'docPage': Routes use DocPage which includes Layout (backward compatible)
   * - 'layoutRoute': Routes use DocContent without Layout (for use with _layout.tsx)
   * Default: 'layoutRoute'
   */
  layoutMode?: 'docPage' | 'layoutRoute'
}

const MAGIC_COMMENT = '// This file is auto-generated by ardo.'

const ROOT_TEMPLATE = `${MAGIC_COMMENT} Do not edit manually.
import { createRootRoute, HeadContent, Scripts } from '@tanstack/react-router'
import config from 'virtual:ardo/config'
import 'ardo/theme/styles.css'

export const Route = createRootRoute({
  head: () => ({
    meta: [
      { charSet: 'utf-8' },
      { name: 'viewport', content: 'width=device-width, initial-scale=1' },
      { title: config.title },
      { name: 'description', content: config.description },
    ],
  }),
  shellComponent: RootDocument,
})

function RootDocument({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <HeadContent />
      </head>
      <body suppressHydrationWarning>
        {children}
        <Scripts />
      </body>
    </html>
  )
}
`

const INDEX_TEMPLATE = `${MAGIC_COMMENT} Do not edit manually.
import { createFileRoute } from '@tanstack/react-router'
import { HomePage } from 'ardo/theme'
import { PressProvider } from 'ardo/runtime'
import config from 'virtual:ardo/config'
import sidebar from 'virtual:ardo/sidebar'
import { frontmatter, toc } from '../../content/index.md'

export const Route = createFileRoute('/')({
  head: () => ({
    meta: [
      { title: (frontmatter.title as string) ? \`\${frontmatter.title} | \${config.title}\` : config.title },
      ...(frontmatter.description ? [{ name: 'description', content: frontmatter.description as string }] : []),
    ],
  }),
  component: HomeComponent,
})

function HomeComponent() {
  const pageData = {
    title: (frontmatter.title as string) || 'Home',
    description: frontmatter.description as string | undefined,
    frontmatter,
    toc,
    filePath: 'index.md',
    relativePath: 'index.md',
  }

  return (
    <PressProvider config={config} sidebar={sidebar} currentPage={pageData}>
      <HomePage />
    </PressProvider>
  )
}
`

const ROUTER_TEMPLATE = `${MAGIC_COMMENT} Do not edit manually.
import { createRouter } from '@tanstack/react-router'
import { routeTree } from './routeTree.gen'

export function getRouter() {
  return createRouter({
    routeTree,
    scrollRestoration: true,
    defaultPreloadStaleTime: 0,
  })
}

export type AppRouter = ReturnType<typeof getRouter>

declare module '@tanstack/react-router' {
  interface Register {
    router: AppRouter
  }
}
`

const VITE_ENV_TEMPLATE = `${MAGIC_COMMENT} Do not edit manually.
/// <reference types="vite/client" />

declare module 'virtual:ardo/config' {
  import type { PressConfig } from 'ardo'
  const config: PressConfig
  export default config
}

declare module 'virtual:ardo/sidebar' {
  import type { SidebarItem } from 'ardo'
  const sidebar: SidebarItem[]
  export default sidebar
}

declare module '*.md' {
  import type { ComponentType } from 'react'
  import type { PageFrontmatter, TOCItem } from 'ardo'

  export const frontmatter: PageFrontmatter
  export const toc: TOCItem[]
  const component: ComponentType
  export default component
}
`

interface CoreFile {
  relativePath: string
  content: string
}

// Note: The (docs) layout is generated dynamically based on routeGroup option
function getLayoutTemplate(routeGroup: string): string {
  return `${MAGIC_COMMENT} Do not edit manually.
import { createFileRoute, Outlet } from '@tanstack/react-router'
import { DocLayout } from 'ardo/theme'
import { PressProvider } from 'ardo/runtime'
import config from 'virtual:ardo/config'
import sidebar from 'virtual:ardo/sidebar'

export const Route = createFileRoute('/(${routeGroup})/_layout')({
  component: DocsLayoutComponent,
})

function DocsLayoutComponent() {
  return (
    <PressProvider config={config} sidebar={sidebar}>
      <DocLayout>
        <Outlet />
      </DocLayout>
    </PressProvider>
  )
}
`
}

const CORE_FILES: CoreFile[] = [
  { relativePath: 'routes/__root.tsx', content: ROOT_TEMPLATE },
  { relativePath: 'routes/index.tsx', content: INDEX_TEMPLATE },
  { relativePath: 'router.tsx', content: ROUTER_TEMPLATE },
  { relativePath: 'vite-env.d.ts', content: VITE_ENV_TEMPLATE },
]

interface RouteInfo {
  /** Path relative to content dir without extension (e.g., 'guide/getting-started') */
  slug: string
  /** Full path to the markdown file */
  mdPath: string
  /** Path relative to content dir with extension (e.g., 'guide/getting-started.md') */
  relativePath: string
}

/**
 * Vite plugin that generates individual route files for each markdown file
 * in the content directory. Routes include SEO head() configuration
 * using frontmatter data.
 */
export function pressRoutesPlugin(
  getConfig: () => ResolvedConfig,
  options: PressRoutesPluginOptions = {}
): Plugin {
  const { routeGroup = 'docs', layoutMode = 'layoutRoute' } = options

  let routesDir: string
  let contentDir: string

  async function scanContentDir(dir: string, rootDir: string): Promise<RouteInfo[]> {
    const routes: RouteInfo[] = []
    const entries = await fs.readdir(dir, { withFileTypes: true })

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name)

      if (entry.isDirectory()) {
        const children = await scanContentDir(fullPath, rootDir)
        routes.push(...children)
      } else if (entry.name.endsWith('.md') && entry.name !== 'index.md') {
        const relativePath = path.relative(rootDir, fullPath)
        const slug = relativePath.replace(/\.md$/, '').replace(/\\/g, '/')

        routes.push({
          slug,
          mdPath: fullPath,
          relativePath: relativePath.replace(/\\/g, '/'),
        })
      } else if (entry.name === 'index.md') {
        const parentDir = path.dirname(fullPath)
        const relativePath = path.relative(rootDir, fullPath)

        // Skip root index.md (handled by manual index.tsx)
        if (parentDir !== rootDir) {
          const slug = path.relative(rootDir, parentDir).replace(/\\/g, '/')

          routes.push({
            slug,
            mdPath: fullPath,
            relativePath: relativePath.replace(/\\/g, '/'),
          })
        }
      }
    }

    return routes
  }

  function scanContentDirSync(dir: string, rootDir: string): RouteInfo[] {
    const routes: RouteInfo[] = []

    try {
      const entries = fsSync.readdirSync(dir, { withFileTypes: true })

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name)

        if (entry.isDirectory()) {
          const children = scanContentDirSync(fullPath, rootDir)
          routes.push(...children)
        } else if (entry.name.endsWith('.md') && entry.name !== 'index.md') {
          const relativePath = path.relative(rootDir, fullPath)
          const slug = relativePath.replace(/\.md$/, '').replace(/\\/g, '/')

          routes.push({
            slug,
            mdPath: fullPath,
            relativePath: relativePath.replace(/\\/g, '/'),
          })
        } else if (entry.name === 'index.md') {
          const parentDir = path.dirname(fullPath)
          const relativePath = path.relative(rootDir, fullPath)

          // Skip root index.md (handled by manual index.tsx)
          if (parentDir !== rootDir) {
            const slug = path.relative(rootDir, parentDir).replace(/\\/g, '/')

            routes.push({
              slug,
              mdPath: fullPath,
              relativePath: relativePath.replace(/\\/g, '/'),
            })
          }
        }
      }
    } catch {
      // Content dir may not exist
    }

    return routes
  }

  function generateRouteCode(route: RouteInfo): string {
    const { slug, relativePath } = route

    // Calculate relative path from route file to content file
    const depthToProjectRoot = slug.split('/').length + 2
    const toProjectRoot = '../'.repeat(depthToProjectRoot)
    const contentImportPath = `${toProjectRoot}content/${relativePath}`

    // Generate component name from slug
    const componentName =
      slug
        .split('/')
        .map((part) => part.replace(/[-_]/g, ' ').replace(/\b\w/g, (c) => c.toUpperCase()))
        .join('')
        .replace(/\s/g, '') + 'Page'

    // Generate route path for TanStack Router
    const routePath = `/(${routeGroup})/${slug}`

    // Generate default title from slug
    const defaultTitle = slug
      .split('/')
      .pop()!
      .replace(/[-_]/g, ' ')
      .replace(/\b\w/g, (c) => c.toUpperCase())

    // Choose component based on layout mode
    const contentComponent = layoutMode === 'docPage' ? 'DocPage' : 'DocContent'

    return `// This file is auto-generated by ardo. Do not edit manually.
import { createFileRoute } from '@tanstack/react-router'
import { ${contentComponent} } from 'ardo/theme'
import { PressProvider } from 'ardo/runtime'
import config from 'virtual:ardo/config'
import sidebar from 'virtual:ardo/sidebar'
import Content, { frontmatter, toc } from '${contentImportPath}'

export const Route = createFileRoute('${routePath}')({
  head: () => ({
    meta: [
      { title: (frontmatter.title as string) ? \`\${frontmatter.title} | \${config.title}\` : config.title },
      ...(frontmatter.description ? [{ name: 'description', content: frontmatter.description as string }] : []),
      // OpenGraph
      { property: 'og:title', content: (frontmatter.title as string) || '${defaultTitle}' },
      ...(frontmatter.description ? [{ property: 'og:description', content: frontmatter.description as string }] : []),
      { property: 'og:type', content: 'article' },
      // Twitter
      { name: 'twitter:card', content: 'summary' },
      { name: 'twitter:title', content: (frontmatter.title as string) || '${defaultTitle}' },
      ...(frontmatter.description ? [{ name: 'twitter:description', content: frontmatter.description as string }] : []),
    ],
  }),
  component: ${componentName},
})

function ${componentName}() {
  const pageData = {
    title: (frontmatter.title as string) || '${defaultTitle}',
    description: frontmatter.description as string | undefined,
    frontmatter,
    toc,
    filePath: '${relativePath}',
    relativePath: '${relativePath}',
  }

  return (
    <PressProvider config={config} sidebar={sidebar} currentPage={pageData}>
      <${contentComponent}>
        <Content />
      </${contentComponent}>
    </PressProvider>
  )
}
`
  }

  async function ensureDirectoryExists(dir: string): Promise<void> {
    try {
      await fs.mkdir(dir, { recursive: true })
    } catch {
      // Directory may already exist
    }
  }

  /**
   * Check if a file is user-created (not auto-generated by ardo).
   * Returns true if file exists and doesn't start with the magic comment.
   * Synchronous version for use in config hook.
   */
  function isUserFileSync(filePath: string): boolean {
    try {
      const content = fsSync.readFileSync(filePath, 'utf-8')
      return !content.startsWith(MAGIC_COMMENT)
    } catch {
      // File doesn't exist
      return false
    }
  }

  /**
   * Write a core file only if:
   * 1. It doesn't exist, OR
   * 2. It exists and is auto-generated (has magic comment) AND content changed
   *
   * User files (without magic comment) are never overwritten.
   * Synchronous version for use in config hook.
   */
  function writeCoreFileSync(filePath: string, content: string): boolean {
    // Check if this is a user-created file
    if (isUserFileSync(filePath)) {
      return false // Don't overwrite user files
    }

    // Only write if content changed
    try {
      const existingContent = fsSync.readFileSync(filePath, 'utf-8')
      if (existingContent === content) {
        return false // No change
      }
    } catch {
      // File doesn't exist, will be created
    }

    fsSync.mkdirSync(path.dirname(filePath), { recursive: true })
    fsSync.writeFileSync(filePath, content, 'utf-8')
    return true
  }

  /**
   * Generate all core TanStack boilerplate files.
   * These files are only written if they don't exist or are auto-generated.
   * User files (without magic comment) are preserved.
   * Synchronous version - must complete before TanStack Start plugin runs.
   */
  function generateCoreFilesSync(srcDir: string): void {
    let writtenCount = 0

    // Generate static core files
    for (const file of CORE_FILES) {
      const filePath = path.join(srcDir, file.relativePath)
      if (writeCoreFileSync(filePath, file.content)) {
        writtenCount++
      }
    }

    // Generate the (docs) layout file (depends on routeGroup option)
    const layoutPath = path.join(srcDir, 'routes', `(${routeGroup})`, '_layout.tsx')
    if (writeCoreFileSync(layoutPath, getLayoutTemplate(routeGroup))) {
      writtenCount++
    }

    if (writtenCount > 0) {
      console.log(`[ardo] Generated ${writtenCount} core files`)
    }
  }

  function writeRouteFileSync(route: RouteInfo): boolean {
    const routeFilePath = path.join(routesDir, `(${routeGroup})`, `${route.slug}.tsx`)
    const code = generateRouteCode(route)

    // Check if this is a user-created file
    if (isUserFileSync(routeFilePath)) {
      return false
    }

    // Only write if content changed
    try {
      const existingContent = fsSync.readFileSync(routeFilePath, 'utf-8')
      if (existingContent === code) {
        return false
      }
    } catch {
      // File doesn't exist, will be created
    }

    fsSync.mkdirSync(path.dirname(routeFilePath), { recursive: true })
    fsSync.writeFileSync(routeFilePath, code, 'utf-8')
    return true
  }

  function generateAllRoutesSync(): void {
    const routes = scanContentDirSync(contentDir, contentDir)

    let writtenCount = 0
    for (const route of routes) {
      if (writeRouteFileSync(route)) {
        writtenCount++
      }
    }

    if (writtenCount > 0) {
      console.log(`[ardo] Generated ${writtenCount} route files`)
    }
  }

  async function writeRouteFile(route: RouteInfo): Promise<boolean> {
    const routeFilePath = path.join(routesDir, `(${routeGroup})`, `${route.slug}.tsx`)
    const routeFileDir = path.dirname(routeFilePath)

    await ensureDirectoryExists(routeFileDir)

    const code = generateRouteCode(route)

    // Only write if content changed to avoid triggering unnecessary rebuilds
    try {
      const existingContent = await fs.readFile(routeFilePath, 'utf-8')
      if (existingContent === code) {
        return false // No change
      }
    } catch {
      // File doesn't exist, will be created
    }

    await fs.writeFile(routeFilePath, code, 'utf-8')
    return true // File was written
  }

  async function cleanGeneratedRoutes(): Promise<void> {
    const pressRoutesDir = path.join(routesDir, `(${routeGroup})`)

    try {
      // Read all files in the directory and delete only auto-generated ones
      const entries = await fs.readdir(pressRoutesDir, { withFileTypes: true, recursive: true })

      for (const entry of entries) {
        if (entry.isFile() && entry.name.endsWith('.tsx')) {
          // Skip _layout.tsx files (manually created)
          if (entry.name === '_layout.tsx') {
            continue
          }

          const filePath = path.join(entry.parentPath ?? entry.path ?? pressRoutesDir, entry.name)

          // Check if file is auto-generated by reading first line
          try {
            const content = await fs.readFile(filePath, 'utf-8')
            if (content.startsWith('// This file is auto-generated by ardo.')) {
              await fs.unlink(filePath)
            }
          } catch {
            // File may have been deleted
          }
        }
      }
    } catch {
      // Directory may not exist
    }
  }

  async function generateAllRoutes(): Promise<void> {
    // Scan for all markdown files
    const routes = await scanContentDir(contentDir, contentDir)

    // In dev mode, clean old routes on first run to remove stale files
    // In build mode, don't clean (routes are already fresh from previous build or dev run)
    if (isDevMode && !hasCleanedRoutes) {
      await cleanGeneratedRoutes()
      hasCleanedRoutes = true
    }

    // Ensure all directories exist first
    const dirs = new Set<string>()
    for (const route of routes) {
      const routeFilePath = path.join(routesDir, `(${routeGroup})`, `${route.slug}.tsx`)
      dirs.add(path.dirname(routeFilePath))
    }
    await Promise.all([...dirs].map((dir) => ensureDirectoryExists(dir)))

    // Generate all route files in parallel (only writes if content changed)
    const results = await Promise.all(routes.map((route) => writeRouteFile(route)))
    const writtenCount = results.filter(Boolean).length

    if (writtenCount > 0) {
      console.log(`[ardo] Generated ${writtenCount} route files`)
    }
  }

  let isDevMode = false
  let hasCleanedRoutes = false

  return {
    name: 'ardo:routes',
    enforce: 'pre',

    config(userConfig, env) {
      // Generate routes early, before TanStack Router scans the files
      const root = userConfig.root || process.cwd()
      const srcDir = path.join(root, 'src')
      routesDir = options.routesDir || path.join(srcDir, 'routes')
      isDevMode = env.command === 'serve'

      // Use srcDir from options to resolve contentDir early
      contentDir = path.resolve(root, options.srcDir || 'content')

      // Generate core files SYNCHRONOUSLY first (router, root route, etc.)
      // This must be synchronous to ensure files exist before TanStack Start plugin runs
      try {
        generateCoreFilesSync(srcDir)
      } catch (err) {
        console.warn('[ardo] Could not generate core files in config phase:', err)
      }

      // Generate content routes SYNCHRONOUSLY as well
      // TanStack Router scans routes during config phase, so routes must exist by then
      try {
        generateAllRoutesSync()
      } catch (err) {
        console.warn('[ardo] Could not generate routes in config phase:', err)
      }
    },

    configResolved(viteConfig) {
      // Update paths if they weren't set in config hook
      if (!routesDir) {
        routesDir = options.routesDir || path.join(viteConfig.root, 'src', 'routes')
        isDevMode = viteConfig.command === 'serve'
      }
    },

    async buildStart() {
      // Generate content routes (async operation, runs after config phase)
      const config = getConfig()
      contentDir = config.contentDir
      await generateAllRoutes()
    },

    async handleHotUpdate({ file, server }) {
      // Only handle markdown files in content directory
      if (!file.endsWith('.md') || !file.startsWith(contentDir)) {
        return
      }

      const relativePath = path.relative(contentDir, file).replace(/\\/g, '/')
      const isIndex = relativePath.endsWith('index.md')

      // Skip root index.md
      if (relativePath === 'index.md') {
        return
      }

      let slug: string
      if (isIndex) {
        slug = path.dirname(relativePath)
      } else {
        slug = relativePath.replace(/\.md$/, '')
      }

      const route: RouteInfo = {
        slug,
        mdPath: file,
        relativePath,
      }

      let needsReload = false

      // Check if file was deleted
      try {
        await fs.access(file)
        // File exists, regenerate route (only if content changed)
        const wasWritten = await writeRouteFile(route)
        if (wasWritten) {
          console.log(`[ardo] Regenerated route: ${slug}`)
          needsReload = true
        }
      } catch {
        // File was deleted, remove route
        const routeFilePath = path.join(routesDir, `(${routeGroup})`, `${slug}.tsx`)
        try {
          await fs.unlink(routeFilePath)
          console.log(`[ardo] Removed route: ${slug}`)
          needsReload = true
        } catch {
          // Route file may not exist
        }
      }

      // Only trigger reload if route file actually changed
      if (needsReload) {
        server.ws.send({
          type: 'full-reload',
          path: '*',
        })
      }
    },
  }
}
