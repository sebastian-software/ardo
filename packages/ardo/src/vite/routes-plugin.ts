import type { Plugin } from 'vite'
import type { ResolvedConfig } from '../config/types'
import fs from 'fs/promises'
import path from 'path'

export interface PressRoutesPluginOptions {
  /** Directory where routes should be generated */
  routesDir?: string
  /** Route group name (default: 'docs') */
  routeGroup?: string
  /** Source directory for content (default: 'content') */
  srcDir?: string
  /**
   * Layout mode for generated routes.
   * - 'docPage': Routes use DocPage which includes Layout (backward compatible)
   * - 'layoutRoute': Routes use DocContent without Layout (for use with _layout.tsx)
   * Default: 'layoutRoute'
   */
  layoutMode?: 'docPage' | 'layoutRoute'
}

interface RouteInfo {
  /** Path relative to content dir without extension (e.g., 'guide/getting-started') */
  slug: string
  /** Full path to the markdown file */
  mdPath: string
  /** Path relative to content dir with extension (e.g., 'guide/getting-started.md') */
  relativePath: string
}

/**
 * Vite plugin that generates individual route files for each markdown file
 * in the content directory. Routes include SEO head() configuration
 * using frontmatter data.
 */
export function pressRoutesPlugin(
  getConfig: () => ResolvedConfig,
  options: PressRoutesPluginOptions = {}
): Plugin {
  const { routeGroup = 'docs', layoutMode = 'layoutRoute' } = options

  let routesDir: string
  let contentDir: string

  async function scanContentDir(dir: string, rootDir: string): Promise<RouteInfo[]> {
    const routes: RouteInfo[] = []
    const entries = await fs.readdir(dir, { withFileTypes: true })

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name)

      if (entry.isDirectory()) {
        const children = await scanContentDir(fullPath, rootDir)
        routes.push(...children)
      } else if (entry.name.endsWith('.md') && entry.name !== 'index.md') {
        const relativePath = path.relative(rootDir, fullPath)
        const slug = relativePath.replace(/\.md$/, '').replace(/\\/g, '/')

        routes.push({
          slug,
          mdPath: fullPath,
          relativePath: relativePath.replace(/\\/g, '/'),
        })
      } else if (entry.name === 'index.md') {
        const parentDir = path.dirname(fullPath)
        const relativePath = path.relative(rootDir, fullPath)

        // Skip root index.md (handled by manual index.tsx)
        if (parentDir !== rootDir) {
          const slug = path.relative(rootDir, parentDir).replace(/\\/g, '/')

          routes.push({
            slug,
            mdPath: fullPath,
            relativePath: relativePath.replace(/\\/g, '/'),
          })
        }
      }
    }

    return routes
  }

  function generateRouteCode(route: RouteInfo): string {
    const { slug, relativePath } = route

    // Calculate relative path from route file to content file
    const depthToProjectRoot = slug.split('/').length + 2
    const toProjectRoot = '../'.repeat(depthToProjectRoot)
    const contentImportPath = `${toProjectRoot}content/${relativePath}`

    // Generate component name from slug
    const componentName =
      slug
        .split('/')
        .map((part) => part.replace(/[-_]/g, ' ').replace(/\b\w/g, (c) => c.toUpperCase()))
        .join('')
        .replace(/\s/g, '') + 'Page'

    // Generate route path for TanStack Router
    const routePath = `/(${routeGroup})/${slug}`

    // Generate default title from slug
    const defaultTitle = slug
      .split('/')
      .pop()!
      .replace(/[-_]/g, ' ')
      .replace(/\b\w/g, (c) => c.toUpperCase())

    // Choose component based on layout mode
    const contentComponent = layoutMode === 'docPage' ? 'DocPage' : 'DocContent'

    return `// This file is auto-generated by ardo. Do not edit manually.
import { createFileRoute } from '@tanstack/react-router'
import { ${contentComponent} } from 'ardo/theme'
import { PressProvider } from 'ardo/runtime'
import config from 'virtual:ardo/config'
import sidebar from 'virtual:ardo/sidebar'
import Content, { frontmatter, toc } from '${contentImportPath}'

export const Route = createFileRoute('${routePath}')({
  head: () => ({
    meta: [
      { title: (frontmatter.title as string) ? \`\${frontmatter.title} | \${config.title}\` : config.title },
      ...(frontmatter.description ? [{ name: 'description', content: frontmatter.description as string }] : []),
      // OpenGraph
      { property: 'og:title', content: (frontmatter.title as string) || '${defaultTitle}' },
      ...(frontmatter.description ? [{ property: 'og:description', content: frontmatter.description as string }] : []),
      { property: 'og:type', content: 'article' },
      // Twitter
      { name: 'twitter:card', content: 'summary' },
      { name: 'twitter:title', content: (frontmatter.title as string) || '${defaultTitle}' },
      ...(frontmatter.description ? [{ name: 'twitter:description', content: frontmatter.description as string }] : []),
    ],
  }),
  component: ${componentName},
})

function ${componentName}() {
  const pageData = {
    title: (frontmatter.title as string) || '${defaultTitle}',
    description: frontmatter.description as string | undefined,
    frontmatter,
    toc,
    filePath: '${relativePath}',
    relativePath: '${relativePath}',
  }

  return (
    <PressProvider config={config} sidebar={sidebar} currentPage={pageData}>
      <${contentComponent}>
        <Content />
      </${contentComponent}>
    </PressProvider>
  )
}
`
  }

  async function ensureDirectoryExists(dir: string): Promise<void> {
    try {
      await fs.mkdir(dir, { recursive: true })
    } catch {
      // Directory may already exist
    }
  }

  async function writeRouteFile(route: RouteInfo): Promise<boolean> {
    const routeFilePath = path.join(routesDir, `(${routeGroup})`, `${route.slug}.tsx`)
    const routeFileDir = path.dirname(routeFilePath)

    await ensureDirectoryExists(routeFileDir)

    const code = generateRouteCode(route)

    // Only write if content changed to avoid triggering unnecessary rebuilds
    try {
      const existingContent = await fs.readFile(routeFilePath, 'utf-8')
      if (existingContent === code) {
        return false // No change
      }
    } catch {
      // File doesn't exist, will be created
    }

    await fs.writeFile(routeFilePath, code, 'utf-8')
    return true // File was written
  }

  async function cleanGeneratedRoutes(): Promise<void> {
    const pressRoutesDir = path.join(routesDir, `(${routeGroup})`)

    try {
      // Read all files in the directory and delete only auto-generated ones
      const entries = await fs.readdir(pressRoutesDir, { withFileTypes: true, recursive: true })

      for (const entry of entries) {
        if (entry.isFile() && entry.name.endsWith('.tsx')) {
          // Skip _layout.tsx files (manually created)
          if (entry.name === '_layout.tsx') {
            continue
          }

          const filePath = path.join(entry.parentPath ?? entry.path ?? pressRoutesDir, entry.name)

          // Check if file is auto-generated by reading first line
          try {
            const content = await fs.readFile(filePath, 'utf-8')
            if (content.startsWith('// This file is auto-generated by ardo.')) {
              await fs.unlink(filePath)
            }
          } catch {
            // File may have been deleted
          }
        }
      }
    } catch {
      // Directory may not exist
    }
  }

  async function generateAllRoutes(): Promise<void> {
    // Scan for all markdown files
    const routes = await scanContentDir(contentDir, contentDir)

    // In dev mode, clean old routes on first run to remove stale files
    // In build mode, don't clean (routes are already fresh from previous build or dev run)
    if (isDevMode && !hasCleanedRoutes) {
      await cleanGeneratedRoutes()
      hasCleanedRoutes = true
    }

    // Ensure all directories exist first
    const dirs = new Set<string>()
    for (const route of routes) {
      const routeFilePath = path.join(routesDir, `(${routeGroup})`, `${route.slug}.tsx`)
      dirs.add(path.dirname(routeFilePath))
    }
    await Promise.all([...dirs].map((dir) => ensureDirectoryExists(dir)))

    // Generate all route files in parallel (only writes if content changed)
    const results = await Promise.all(routes.map((route) => writeRouteFile(route)))
    const writtenCount = results.filter(Boolean).length

    if (writtenCount > 0) {
      console.log(`[ardo] Generated ${writtenCount} route files`)
    }
  }

  let isDevMode = false
  let hasCleanedRoutes = false
  let hasGeneratedRoutes = false

  return {
    name: 'ardo:routes',
    enforce: 'pre',

    async config(userConfig, env) {
      // Generate routes early, before TanStack Router scans the files
      const root = userConfig.root || process.cwd()
      routesDir = options.routesDir || path.join(root, 'src', 'routes')
      isDevMode = env.command === 'serve'

      // Use srcDir from options to resolve contentDir early
      contentDir = path.resolve(root, options.srcDir || 'content')

      // Generate routes now, before other plugins run
      try {
        await generateAllRoutes()
        hasGeneratedRoutes = true
      } catch (err) {
        // Content dir may not exist yet, will try again in buildStart
        console.warn('[ardo] Could not generate routes in config phase:', err)
      }
    },

    configResolved(viteConfig) {
      // Update paths if they weren't set in config hook
      if (!routesDir) {
        routesDir = options.routesDir || path.join(viteConfig.root, 'src', 'routes')
        isDevMode = viteConfig.command === 'serve'
      }
    },

    async buildStart() {
      // Only generate routes here if we couldn't do it in the config hook
      if (!hasGeneratedRoutes) {
        const config = getConfig()
        contentDir = config.contentDir
        await generateAllRoutes()
      }
    },

    async handleHotUpdate({ file, server }) {
      // Only handle markdown files in content directory
      if (!file.endsWith('.md') || !file.startsWith(contentDir)) {
        return
      }

      const relativePath = path.relative(contentDir, file).replace(/\\/g, '/')
      const isIndex = relativePath.endsWith('index.md')

      // Skip root index.md
      if (relativePath === 'index.md') {
        return
      }

      let slug: string
      if (isIndex) {
        slug = path.dirname(relativePath)
      } else {
        slug = relativePath.replace(/\.md$/, '')
      }

      const route: RouteInfo = {
        slug,
        mdPath: file,
        relativePath,
      }

      let needsReload = false

      // Check if file was deleted
      try {
        await fs.access(file)
        // File exists, regenerate route (only if content changed)
        const wasWritten = await writeRouteFile(route)
        if (wasWritten) {
          console.log(`[ardo] Regenerated route: ${slug}`)
          needsReload = true
        }
      } catch {
        // File was deleted, remove route
        const routeFilePath = path.join(routesDir, `(${routeGroup})`, `${slug}.tsx`)
        try {
          await fs.unlink(routeFilePath)
          console.log(`[ardo] Removed route: ${slug}`)
          needsReload = true
        } catch {
          // Route file may not exist
        }
      }

      // Only trigger reload if route file actually changed
      if (needsReload) {
        server.ws.send({
          type: 'full-reload',
          path: '*',
        })
      }
    },
  }
}
